<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zavierlyu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="语言只是实现目标的工具，而不是目标本身。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java核心技术 卷1》笔记">
<meta property="og:url" content="http://zavierlyu.github.io/2021/01/27/javacore1/index.html">
<meta property="og:site_name" content="Garden of Sinners">
<meta property="og:description" content="语言只是实现目标的工具，而不是目标本身。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210116163253477.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210120164650787.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210120164734643.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210120165712075.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210126221230569.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210128160458104.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210412191036952.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210412191504156.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210417200637863.png">
<meta property="og:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210406184642799.png">
<meta property="article:published_time" content="2021-01-27T09:28:46.000Z">
<meta property="article:modified_time" content="2021-07-11T17:47:39.512Z">
<meta property="article:author" content="Zhewen Lyu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zavierlyu.github.io/2021/01/27/javacore1/image-20210116163253477.png">

<link rel="canonical" href="http://zavierlyu.github.io/2021/01/27/javacore1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>《Java核心技术 卷1》笔记 | Garden of Sinners</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Garden of Sinners</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-cv">

    <a href="/cv/ZhewenLyu-CUHKSZ-eng.pdf" rel="section"><i class="fa fa-user fa-fw"></i>cv</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/ZavierLyu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zavierlyu.github.io/2021/01/27/javacore1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhewen Lyu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Garden of Sinners">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Java核心技术 卷1》笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-27 17:28:46" itemprop="dateCreated datePublished" datetime="2021-01-27T17:28:46+08:00">2021-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-12 01:47:39" itemprop="dateModified" datetime="2021-07-12T01:47:39+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Backend/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em>语言只是实现目标的工具，而不是目标本身。</em></p>
<span id="more"></span>

<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ol>
<li>不要在程序中使用char，最好将字符串作为抽象数据处理</li>
<li>整数和布尔值之间不能相互转换</li>
<li>一定不要使用“==”运算符检测两个字符串是否相等，判断的是两个字符串是否存放在相同的位置。以及其他装箱类比如(Integer)，而是使用<code>equals</code>。这个运算符只能确定两个字符串是否放置在同一个位置上。<strong>Integer只在-128～127有缓存， ==只会比较缓存是否一致，也就是指向的地址是否一致。所以(Integer)129 == (Integer)129是false。</strong></li>
<li>有些时候需要由较短的字符串构建长字符串，每次拼接将会产生一个长字符串，比较浪费时间和空间。所以使用<code>StringBuilder</code>类就可以解决这个问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(ch); <span class="comment">// append a char;</span></span><br><span class="line">builder.append(str); <span class="comment">// append a string</span></span><br><span class="line">String completedString = builder.toString();</span><br></pre></td></tr></table></figure></li>
<li>用于printf的转换符<img src="/2021/01/27/javacore1/image-20210116163253477.png" class="" title="basic_1"></li>
<li>匿名数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 既有数组初始化</span></span><br><span class="line">smallPrimes = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 可以代替以下代码</span></span><br><span class="line"><span class="keyword">int</span>[] anonymous = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>&#125;;</span><br><span class="line">smallPrimes = anonymous;</span><br></pre></td></tr></table></figure></li>
<li>For each循环<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for (variable : collection) statement</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> element: array)</span><br><span class="line">  System.out.println(element);</span><br></pre></td></tr></table></figure></li>
<li>数组拷贝<br>新数组拷贝旧数组中的各元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">int</span>[] copiedArray = Arrays.copyOf(Array, Array.length);</span><br></pre></td></tr></table></figure></li>
<li><code>java.util.Arrays</code><img src="/2021/01/27/javacore1/image-20210120164650787.png" class="">
<img src="/2021/01/27/javacore1/image-20210120164734643.png" class=""></li>
<li>不规则数组<br>Java 实际上没有多维数组， 只有一维 数组。 多维数组被解释为<strong>数组的数组</strong>。<img src="/2021/01/27/javacore1/image-20210120165712075.png" class="">
所以我们可以非常方便的作出一个将不同长度的数组作为元素的数组:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] triangleArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  triangleArray[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样我们就可以节省空间，方便遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span>; r &lt; triangleArray.length; r++) </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> c=<span class="number">0</span>; c &lt; triangleArray[r].length; c++) &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="注意不要编写返回引用可变对象的访问器方法"><a href="#注意不要编写返回引用可变对象的访问器方法" class="headerlink" title="注意不要编写返回引用可变对象的访问器方法"></a>注意不要编写返回引用可变对象的访问器方法</h4><p>   bad example:<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date hireDay;</span><br><span class="line">	<span class="keyword">public</span> Date getHireDay &#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   这样会造成如下结果:<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee Jobs = <span class="keyword">new</span> Employee();</span><br><span class="line">Date d = Jobs.getHireDay();</span><br><span class="line">d.setTime(d.getTime() - <span class="number">100</span>); <span class="comment">// 这会造成Jobs里面的hireDay也会发生变化</span></span><br></pre></td></tr></table></figure><br>    <img src="/2021/01/27/javacore1/image-20210126221230569.png" class="" title="class_01"><br>   <strong>如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)。</strong><br>   revised:<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date hireDay;</span><br><span class="line">	<span class="keyword">public</span> Date getHireDay &#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="一个类的方法可以访问这个类的任意对象的私有域"><a href="#一个类的方法可以访问这个类的任意对象的私有域" class="headerlink" title="一个类的方法可以访问这个类的任意对象的私有域"></a>一个类的方法可以访问这个类的任意对象的私有域</h4><h4 id="final实例域，构建对象时必须初始化这样的域。"><a href="#final实例域，构建对象时必须初始化这样的域。" class="headerlink" title="final实例域，构建对象时必须初始化这样的域。"></a><strong>final实例域</strong>，构建对象时必须初始化这样的域。</h4><ul>
<li>如果该对象是不可更改类型，如String，在后面的操作中，不能对它进行修改。</li>
<li>如果该对象是可更改类型，如Date，在后面的操作中，该对象的引用不能指向其他对象，但是该对象可以修改。</li>
</ul>
<h4 id="static静态域和静态方法"><a href="#static静态域和静态方法" class="headerlink" title="static静态域和静态方法"></a><strong>static静态域和静态方法</strong></h4><ul>
<li>如果将域定义为static，每个类中只能有一个这样的域。所有的实例共享一个静态域。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id = nextId;</span><br><span class="line">    nextId++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
即使没有一个Employee实例，<code>nextId</code>也存在，它属于类不属于实例。    </li>
<li>静态常量（用的比较多）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如果没有static，需要每次创建一个实例才能调用该常量</strong>。<strong>如果只有static没有final，每个实例都能更改共有静态域。</strong></p>
<ul>
<li><p>静态方法<br>当有以下两种需求的时候可以使用静态方法：</p>
<ol>
<li>方法不需要访问对象状态， 其所需参数都只通过显式参数提供(例如: Math.pow )</li>
<li>方法只访问类的静态域</li>
</ol>
<p><strong>静态方法不能调用非静态实例域（隐式参数），因为实例域只有实例才有的域，而静态方法可以不创建实例就被调用，所以这种会引起错误的写法被禁止。</strong></p>
</li>
<li><p>静态工厂方法<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ceb5ec8f1174">Reference</a><br>主要用途：摒弃用new和构造函数来创建实例的方法。<br>在外部调用的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat currencyFormat = NumberFormat.getCurrencyInstance();</span><br><span class="line">NumberFormat percentFromat = Numberformat.getPercentInstance();</span><br><span class="line">Integer number = Integer.valueOf(<span class="string">&quot;3&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>每个对象的创建都有相应的名称，可读性高<br>bad example: 全部用构造器创建，可读性低。(现在Date类都已经标记Depreciated)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">121</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
good example:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.valueOf(<span class="string">&quot;2021-12-25&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>工厂方法实现<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eb30a388c5fc">单例</a></li>
<li>返回子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPlayerInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Player();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getCookerInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cooker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Player extends Person&#123;</span><br><span class="line">&#125;</span><br><span class="line">Class Cooker extends Person&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解决构造器重载无法实现的函数签名相同的情况<br> 构造函数重载的缺陷:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123; <span class="comment">// ERROR: 函数签名重复</span></span><br><span class="line">      <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
工厂方法实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> weight = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Child <span class="title">newChild</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.weight = weight;</span><br><span class="line">        child.age = age;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Child <span class="title">newChildWithWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.weight = weight;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Child <span class="title">newChildWithAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.age = age;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>减少不必要的属性暴露<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RUNNER = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SWIMMER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RACER = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Player</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123; <span class="comment">// 构造函数隐藏，避免外部调用</span></span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Player <span class="title">newRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Player(TYPE_RUNNER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Player <span class="title">newSwimmer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Player(TYPE_SWIMMER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Player <span class="title">newRacer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Player(TYPE_RACER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试的时候不用每次都要重新创建实例赋值<br>如果要写一连串的测试代码，如果需要测试的界面有多个，那么这一连串的代码可能还会被复制多次到项目的多个位置。用静态工厂方法代替手写构造器更为方便也使代码更加整洁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    String name ;</span><br><span class="line">    <span class="keyword">int</span> age ;</span><br><span class="line">    String description;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">newTestInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User tester = <span class="keyword">new</span> User();</span><br><span class="line">        tester.setName(<span class="string">&quot;隔壁老张&quot;</span>);</span><br><span class="line">        tester.setAge(<span class="number">16</span>);</span><br><span class="line">        tester.setDescription(<span class="string">&quot;我住隔壁我姓张！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tester;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的时候</span></span><br><span class="line"><span class="comment">/* AccountTester.java */</span></span><br><span class="line">User tester = User.newTestInstance();</span><br><span class="line">bindAccount(tester);</span><br><span class="line"><span class="comment">/* UiTester.java */</span></span><br><span class="line">User tester = User.newTestInstance();</span><br><span class="line">bindUI(tester);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造器时的混乱</span></span><br><span class="line"><span class="comment">/* AccountTester.java */</span></span><br><span class="line">User tester = <span class="keyword">new</span> User();</span><br><span class="line">tester.setName(<span class="string">&quot;隔壁老张&quot;</span>);</span><br><span class="line">tester.setAge(<span class="number">16</span>);</span><br><span class="line">tester.setDescription(<span class="string">&quot;我住隔壁我姓张！&quot;</span>);</span><br><span class="line">bindAccount(tester);</span><br></pre></td></tr></table></figure></li>
<li><p><code>main方法</code>: 每一个类可以有一个 main 方法。这是一个常用于对类进行单元测试的技巧。</p>
</li>
</ul>
<h4 id="this构造方法"><a href="#this构造方法" class="headerlink" title="this构造方法:"></a><code>this构造方法</code>:</h4><ol>
<li>Java 要求，在构造方法中如果使用关键字 this 调用其他构造方法，则 this(参数列表) 语句必须出现在其他语句之前。</li>
<li><code>this</code>不能在静态代码块中使用：由于<code>this</code>代表的是对象的引用，因此依赖于具体对象。</li>
</ol>
<h4 id="可见性修饰符和数据域封装"><a href="#可见性修饰符和数据域封装" class="headerlink" title="可见性修饰符和数据域封装"></a>可见性修饰符和数据域封装</h4><table>
<thead>
<tr>
<th align="center">可见型修饰符</th>
<th align="center">类内访问</th>
<th align="center">包内访问</th>
<th align="center">从子类访问</th>
<th>从不同包访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td>可以</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td>不可以</td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">不可以</td>
<td>不可以</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">可以</td>
<td align="center">不可以</td>
<td align="center">不可以</td>
<td>不可以</td>
</tr>
</tbody></table>
<p>子类可以覆盖父类的 protected 方法，并把该方法的可见性改成 public。但是子类不能降低父类方法的可见性，即不能把父类的 public 方法的可见性改成 protected。</p>
<h4 id="类设计方法建议"><a href="#类设计方法建议" class="headerlink" title="类设计方法建议"></a>类设计方法建议</h4><ol>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型，必要时新开类来代替一些实例域</li>
<li>不是所有的域都需要独立的域访问器和域更改器</li>
<li>将职责过多的类进行拆分</li>
<li>类名和方法名要提现他们的职责</li>
<li>优先使用不可变的类</li>
</ol>
<h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>Java程序设计语言总是采用按值调用。 也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x, Employee y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此时的x和y，只是引用的拷贝而不是引用本身</span></span><br><span class="line">  Employee tmp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = tmp;</span><br><span class="line">&#125;</span><br><span class="line">Employee a = <span class="keyword">new</span> Employee(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">Employee b = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">swap(a, b); <span class="comment">// 并不会交换 a 和 b</span></span><br></pre></td></tr></table></figure>

<img src="/2021/01/27/javacore1/image-20210128160458104.png" class="">

<p><strong>Java程序设计语言对对象采用的不是引用调用，对象是按值传递的。</strong></p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态（用实例的方法比如setType())</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ol>
<li>子类的方法返回值类型可以和父类不完全一致。如果返回值类型是基本数据类型或者<code>void</code>，则必须一致。如果返回值类型是引用类型，则要求返回值类型相同或者子类的方法的返回值类型是负累的烦法的返回值类型的子类。</li>
<li>重载和重写的区别：重载指在同一个类中定义多个方法，这些方法有相同的名称，但是方法签名不同；重写指在子类中定义一个方法，该方法与父类中的方法的签名相同。</li>
</ol>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类和常规类一样具有数据域、方法和构造方法，但是不能用<code>new</code>操作符创建实例。</p>
<ol>
<li>抽象类可包含抽象方法，也可以不包含抽象方法，抽象方法同样要用<code>abstract</code>修饰，只有方法签名而没有实现</li>
<li>非抽象类不能包含抽象。如果一个抽象父类的子类不能实现所有的抽象方法，则该子类也必须声明为抽象类</li>
<li>包含抽象方法的类必须声明为抽象类</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态存在的三个必要条件</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>
</ul>
<p>能力: 同一个行为具有多个不同表现形式或形态。</p>
<p>以下例子输出<code>A C</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a=<span class="keyword">new</span> A();</span><br><span class="line">        a.show();</span><br><span class="line">        A c=<span class="keyword">new</span> C();</span><br><span class="line">        c.show();</span><br><span class="line">        <span class="comment">// 同样是A类引用变量，同样调用show方法，有不同的表现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        show2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ol>
<li>抽象类的变量没有限制，接口只包含常量，即接口的所有变量必须是<code>public static final</code>。</li>
<li>抽象类包含构造方法，子类通过构造方法链调用构造方法，接口不包含构造方法。</li>
<li>抽象类的方法没有限制</li>
<li>一个类只能继承一个负累，但是可以实现多个接口。一个接口可以继承多个接口。</li>
</ol>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>用于检测一个对象是否等于另外一个对象。在Object类中，这两个方法将判断两个对象是否具有相同的引用，但是在类的重写中一般会改成值比较。</p>
<p>Java语言规范要求equals方法具有下面的特性：</p>
<ol>
<li>自反性：<code>x.equals(x)</code>应该返回true</li>
<li>对称性：当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>也应该返回true</li>
<li>传递性：如果<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true，<code>x.equals(z)</code>也应该返回true</li>
<li>一致性：如果x和y引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果</li>
<li>对于任意非空引用x，<code>x.equals(null)</code>应该返回false</li>
</ol>
<p>编写equals方法的建议：</p>
<ol>
<li>显式参数命名为otherObject，稍后需要将它根据需要进行类型转换成other</li>
<li>检测this与otherObject是否引用同一个对象：</li>
</ol>
<p><code>if (this == otherObject) return true</code></p>
<ol start="3">
<li>检测otherObject是否为null，如果为null，返回false</li>
</ol>
<p><code>if (otherObject == null) return false</code></p>
<ol start="4">
<li>比较this与otherObject是属于一个类或者有一个共同子类</li>
</ol>
<p>比如ArrayList中的equals比较:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="comment">// ArrayList can be subclassed and given arbitrary behavior, but we can</span></span><br><span class="line">  <span class="comment">// still deal with the common case where o is ArrayList precisely</span></span><br><span class="line">  <span class="keyword">boolean</span> equal = (o.getClass() == ArrayList.class)</span><br><span class="line">    ? equalsArrayList((ArrayList&lt;?&gt;) o)</span><br><span class="line">    : equalsRange((List&lt;?&gt;) o, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">  checkForComodification(expectedModCount);</span><br><span class="line">  <span class="keyword">return</span> equal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将otherObject转换成相应的类类型</li>
<li>使用<code>==</code>比较基本类型域，使用equals比较对象域</li>
</ol>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h5><ul>
<li><p>Object类中默认的散列码为对象的存储地址。</p>
</li>
<li><p><strong>如果重新定义equals方法，就必须重新定义hashCode</strong>，以便用户可以将对象插入到散列表中。</p>
</li>
<li><p>hashCode方法应该返回一个整型数值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀</p>
</li>
<li><p>hashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀</p>
</li>
<li><p>如果组合和多个散列值时，可以简单的写成<code>Objects.hash(name, salary, hiredat)</code></p>
</li>
<li><p>Equals 与 hashCode 的定义必须一致: 如果 x.equals(y) 返回 true, 那么 x.hashCode( ) 就必须与 y.hashCode( ) 具有相同的值</p>
</li>
</ul>
<h6 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode?"></a>为什么要有 <strong>hashCode</strong>?</h6><p>我们以“ HashSet 如何检查重复”为例子来说明为什么要有 hashCode。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比􏰁，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方 法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<h6 id="为什么重写-equals-时必须重写-hashCode-方法"><a href="#为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="为什么重写 equals 时必须重写 hashCode 方法?"></a>为什么重写 <strong>equals</strong> 时必须重写 <strong>hashCode</strong> 方法?</h6><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此， <strong>equals</strong> 方法被覆盖过，则 <strong>hashCode</strong> 方法也必须被覆盖。还有就是，<strong>hashCode() 的默认行为是对堆上的对象地址产生独特值</strong>。如果没有重写 hashCode() ，则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)。</p>
<blockquote>
<p>如果存在数组类型的域，可以使用静态的Arrays.hashCode方法计算散列码，这个散列码由数组元素的散列码组成。</p>
</blockquote>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><p>用于返回表示对象值的字符串。</p>
<p><strong>Object类默认定义打印输出对象所属的类名和散列码</strong>。</p>
<p>试例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toStirng</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName()</span><br><span class="line">    + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">    + <span class="string">&quot;,salary=&quot;</span> + salary</span><br><span class="line">    + <span class="string">&quot;,hireDay=&quot;</span> + hireDay</span><br><span class="line">    + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toStirng</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.toString()</span><br><span class="line">    + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">    + <span class="string">&quot;,salary=&quot;</span> + salary</span><br><span class="line">    + <span class="string">&quot;,hireDay=&quot;</span> + hireDay</span><br><span class="line">    + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><p>对象包装器类(wrapper): Integer, Long, Float, Double, Short, Byte, Character, Void, Boolean. (前6个类派生于公共的超类Number)</p>
<p>**自动装箱(autoboxing)**： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);<span class="comment">// 将自动变换成</span></span><br><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p><strong>自动拆箱</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = list.get(i); <span class="comment">// 将自动转换成</span></span><br><span class="line"><span class="keyword">int</span> n = list.get(i).intValue();</span><br></pre></td></tr></table></figure>

<p>如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱提升为double，再装箱为Double。</p>
<blockquote>
<p>装箱和拆箱是编译器认可的而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</p>
</blockquote>
<p>自动装箱规范要求boolean, byte, char &lt;= 127, 介于-128~127之间的short和int被包装到固定的对象中。例如，如果在前面的例子中将a和b初始化为100, 对他们进行==比较的结果一定成立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">Integer c = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">Integer d = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">System.out.println(c == d); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>... values)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> largest = Double.NEGATIVE_INFINITY;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">double</span> v: values) <span class="keyword">if</span> (v &gt; largest) largest = v;</span><br><span class="line">  <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> m = max(<span class="number">3.1</span>, <span class="number">4.4</span>, -<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>简单的枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE &#125;;</span><br></pre></td></tr></table></figure>

<p>定义构造器、方法和域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造器只在构造枚举长江的时候被调用</p>
</blockquote>
<p>所有的枚举类型都是Enum类的子类，因此继承了一些 Enum方法:</p>
<ul>
<li><code>static Enum valueOf(Class enumClass, String name)</code>: 返回制定名字，给定类的枚举常量</li>
<li><code>String toString()</code>: 返回枚举常量名</li>
<li><code>int ordinal()</code>: 返回枚举亮在enum声明中的位置，位置从0开始计数</li>
<li><code>int compareTo(E other)</code>: 如果枚举常量出现在other之前，则返回一个负值；如果this==other, 返回0；否则返回正值。</li>
</ul>
<h4 id="反射-reflective"><a href="#反射-reflective" class="headerlink" title="反射(reflective)"></a>反射(reflective)</h4><p>反射机制的功能:</p>
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象</li>
</ol>
<h5 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h5><p>获得类对应的Class对象的方法:</p>
<ol>
<li>getClass</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">Class cl = generator.getClass();</span><br><span class="line">String name = cl.getName();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>静态方法Class.forName</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">Class cl = Class.forName(className);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>直接获取了心的类对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cl1 = Random.class; </span><br><span class="line">Class cl2 = <span class="keyword">int</span>.class;</span><br></pre></td></tr></table></figure>

<p>动态创建一个类的实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.getClass().newInstance();</span><br></pre></td></tr></table></figure>

<h5 id="检查类的结构"><a href="#检查类的结构" class="headerlink" title="检查类的结构"></a>检查类的结构</h5><img src="/2021/01/27/javacore1/image-20210412191036952.png" class="">

<img src="/2021/01/27/javacore1/image-20210412191504156.png" class="">

<h5 id="运行时反射分析对象域"><a href="#运行时反射分析对象域" class="headerlink" title="运行时反射分析对象域"></a>运行时反射分析对象域</h5><p>反射方法不仅可以知晓实例类的域名，方法名和修饰符等，还可以在运行时查看对象域的值。如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj域的当前值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Kane&quot;</span>, <span class="number">35000</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1999</span>);</span><br><span class="line">Class cl = harry.getClass();</span><br><span class="line">Field f = cl.getDeclaredField(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">// 由于域为私有域，所以要设置权限</span></span><br><span class="line">Object v = f.get(harry); <span class="comment">// 获取</span></span><br><span class="line">f.set(harry, <span class="number">50000</span>); <span class="comment">// 设置</span></span><br></pre></td></tr></table></figure>

<h5 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h5><p>目标：实现一个通用方法能将任何数组复制并转换成Object[], 类似Arrays.copyOf()</p>
<p>错误示范:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">  Object[] newArray = <span class="keyword">new</span> Object[newLength];</span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(a.length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时生成的对象数组不能再转换为Employee[]，否则会产生ClassCastException。将一个Employee[]临时地转换成Object[]数组，然后再把它转换回来是可以的，但一个从开始底层就是Object[]的数组却永远不能转换成Employee[]数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Object[] c = (Object[]) a;</span><br><span class="line">Integer[] d = (Integer[]) c; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">Object[] x = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">Integer[] e = (Integer[]) x; <span class="comment">// ClassCastException</span></span><br></pre></td></tr></table></figure>

<p>因此我们需要动态的创建与原数组类型相同的新数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object newArray = Array.newInstance(componentType, newLength);</span><br></pre></td></tr></table></figure>

<p>为了获得型数组元素类型，就需要进行以下工作:</p>
<ol>
<li>首先获得a数组的类对象</li>
<li>确认它是一个数组</li>
<li>使用Class类（只能定义表示数组的类对象）的getComponentType方法确定数组对应的类型</li>
</ol>
<p>正确示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由于int[]不可以转换成Object[], 所以参数声明应该是 Object</span></span><br><span class="line">  Class cl = a.getClass();</span><br><span class="line">  <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  Class componentType = cl.getComponentType();</span><br><span class="line">  <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">  Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">  System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h5 id="传递类方法（类似函数指针）"><a href="#传递类方法（类似函数指针）" class="headerlink" title="传递类方法（类似函数指针）"></a>传递类方法（类似函数指针）</h5><ol>
<li>通过反射得到方法</li>
</ol>
<p>getMethod的函数签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class... parameterTypes)</span> <span class="comment">//匹配重载所以是多参列表</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method sqrt = Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="keyword">double</span>.class);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过Method类中的invoke方法调用包装在当前Method对象中的方法</li>
</ol>
<p>invoke方法的函数签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure>

<p>obj表示所要调用方法的实例，通过实例来调用隐式参数，如果是静态方法的话可以为null</p>
<p>args表示显示参数</p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印sqrt和sqr列表</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method m_sq, m_sqrt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m_sq = reflection.class.getMethod(<span class="string">&quot;square&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line">            m_sqrt = Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line">            printTable(<span class="number">0f</span>, <span class="number">10f</span>, <span class="number">5</span>, m_sq);</span><br><span class="line">            printTable(<span class="number">0f</span>, <span class="number">10f</span>, <span class="number">5</span>, m_sqrt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from, <span class="keyword">double</span> to, <span class="keyword">int</span> n, Method f)</span> </span>&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> x = from; x &lt;= to; x += dx)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> y = (Double) f.invoke(<span class="keyword">null</span>, x);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%8.4f | %8.4f%n&quot;</span>, x, y);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h4><ol>
<li>将公共操作和域放在超类</li>
<li>不要使用受保护的域</li>
</ol>
<p>有些程序员认为，将大多数的实例域定义为 protected 是一个不错的主意，只有这样，子类才能够在需要的时候直接访问它们。然而，protected机制并不能够带来更好的保护，其原因主要有亮点。第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的实例域，从而破坏了封装性。第二，在Java中，在同一个包中的所有类都可以访问protected域，而不管它是否为这个类的子类。</p>
<ol start="3">
<li>使用继承实现”is-a”关系</li>
<li>除非<strong>所有继承的方法都有意义</strong>，否则不要使用继承</li>
</ol>
<p>使用Holiday继承java.util.GregorianCalendar? No, 继承了的Holiday不是封闭的，GregorianCalendar的公有方法add，可以将假日转换成非假日，又因为重写不能缩小可见性，所以继承add对Holiday来说毫无意义。</p>
<ol start="3">
<li>在覆盖方法时，不要改变预期的行为</li>
</ol>
<p>里式置换原则不仅应用于语法，而且也可以应用于行为，这更加重要。紧接上文，如果你仍要坚持Holiday继承GregorianCalendar，或许你可以想到重写add方法但是并不做真正的添加操作，或抛出异常，或什么也不做，或继续到下一个假日，然而这些都违反了置换原则。</p>
<ol start="4">
<li>使用多态，而非类型信息</li>
</ol>
<p>Never code like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> T1)</span><br><span class="line">  action1(x)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> T2)</span><br><span class="line">  action2(x);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>不要过多地使用反射</li>
</ol>
<h3 id="接口、lambda表达式和内部类"><a href="#接口、lambda表达式和内部类" class="headerlink" title="接口、lambda表达式和内部类"></a>接口、lambda表达式和内部类</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ol>
<li>接口中所有方法自动地属于public</li>
<li>接口绝不能含有实例域，但可以包含常量（自动设为public static final）</li>
<li>可以使用instanceof检查一个对象是否实现了某个特定的接口</li>
<li>接口也可以继承（扩展）接口</li>
<li>在Java SE 8中，允许在接口中增加静态方法</li>
<li>可以为接口方法提供一个默认实现，这样实现类就可以挑选自己想要实现的方法实现，还可以解决“接口演化”的兼容问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// An abstract method</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="默认方法冲突"><a href="#默认方法冲突" class="headerlink" title="默认方法冲突"></a>默认方法冲突</h5><p>情况一：实现两个接口，只要这两个接口的方法中有两个的函数签名相同并且其中至少有一个是默认方法，就必须解决二义性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot; &quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java编译器会报告一个错误，让程序员来解决这个二义性，可以选择两个冲突方法中的一个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Named</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况二（类优先）：继承一个超类，实现一个接口，超类包含了和接口默认方法同名的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot; Named &quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot; Person &quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Named</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>此时调用Student实例的getName()将会只使用超类方法，接口对应的默认方法将会被忽略。</p>
<h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p>默认的Object类clone方法是浅拷贝，只有实现Cloneable接口才能完成深拷贝。</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><h5 id="表达式例子"><a href="#表达式例子" class="headerlink" title="表达式例子"></a>表达式例子</h5><ol>
<li>参数类型，参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>泛型参数可推</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>单参可推</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActionListener listener = event -&gt;</span><br><span class="line">  System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无参</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h5><img src="/2021/01/27/javacore1/image-20210417200637863.png" class="">

<p><code>函数式接口</code>: 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式</p>
<p>最好把lambda表达式看作是一个函数，而不是一个对象，另外lambda表达式可以传递到函数时接口。对lambda表达式所能做的也只是能转换为函数式接口。</p>
<p>如果想要用lambda表达式做某些处理，可以用一些特定的函数式接口比如java.util.function.Predicate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList类有一个removeIf方法，它的参数就是一个Predicate。这个接口专门用来传递lambda表达式，<code>list.removeIf(e -&gt; e == null)</code>。</p>
<h5 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, System.out::println);</span><br><span class="line">Arrays.sort(strings, String::compareToIgnoreCase); <span class="comment">// 对字符串排序而不考虑字母的大小写。</span></span><br></pre></td></tr></table></figure>

<p>表达式System.out::println是一个方法引用(method reference)，它等价于lambda表达式<code>x -&gt; System.out.println(x)</code>。</p>
<p>用操作符分隔方法名与对象或类名的几种情况:</p>
<ol>
<li><code>object::instanceMethod</code></li>
<li><code>Class::staticMethod</code></li>
<li><code>Class::instanceMethod</code></li>
<li><code>super::instanceMethod</code></li>
<li><code>this::instanceMethod</code></li>
</ol>
<h5 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h5><p>构造器引用的方法名为new，如<code>Person::new</code>，构造器的选择取决于上下文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = strean.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>可以用数组类型建立构造器引用：<code>int[]::new</code>是一个构造器引用，它有一个参数即数组的长度，这等价于lambda表达式<code>x-&gt;new int[x]</code>。</p>
<h5 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h5><p>lambda表达式中访问外围方法或类中的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">  ActionListener listener = event -&gt; &#123;</span><br><span class="line">    System.out.println(text);</span><br><span class="line">    Toolkit.getDefaultToolkit().beep();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeatMessage(<span class="string">&quot;Hello&quot;</span>, <span class="number">1000</span>); <span class="comment">// Prints Hello every 1,000 milliseconds</span></span><br></pre></td></tr></table></figure>

<p>lambda表达式的3个部分:</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值，指非参数而且不在代码中定义的变量</li>
</ol>
<p>lambda表达式中的自由变量text，因为会出现repeatMessage方法已经返回其本地变量被回收，但是其中的lambda函数还在每秒打印text，所以表示lambda表达式的数据结构必须存储自由变量的值。我们说它被lambda表达式捕获(captured)，这样的lambda表达式可以称之为闭包(closure)。<strong>在lambda表达式中，自由变量只能引用值不会改变的变量</strong>。</p>
<p>下面几个案例是不合法的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">  ActionListener listener = event -&gt; &#123;</span><br><span class="line">    start--; <span class="comment">// Error: Can&#x27;t mutate captured variable</span></span><br><span class="line">    System.out.println(start);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在lambda表达式中改变变量，并发执行多个动作时就会不安全。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(String text, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line">      System.out.println(i + <span class="string">&quot;: &quot;</span> + text); <span class="comment">// Error: Cannot refer to changing i</span></span><br><span class="line">  &#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(<span class="number">1000</span>, listener).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自由变量外部可变，不合法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path first = Paths.get(<span class="string">&quot;/usr/bin&quot;</span>);</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line"><span class="comment">// Error: Variable fist already defined</span></span><br></pre></td></tr></table></figure>

<p><strong>lambda表达式中捕获的变量必须实际上是最终变量(effectively final)</strong></p>
<p><strong>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Application</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.toString()); <span class="comment">// 调用Application的toString而不是ActionListener实例方法</span></span><br><span class="line">      <span class="comment">// 方法作用域嵌套在init方法中，与init中的其他代码块一样，this含义不变</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h5><p>使用lambda表达式的重点是延迟执行(deferred execution)，毕竟，如果想要立即执行代码，完全可以直接执行，而无需把它包装在一个lambda表达式中。</p>
<p>原因：</p>
<ol>
<li>在一个单独的线程中运行代码</li>
<li>多次运行代码</li>
<li>在算法的适当位置于心代码</li>
<li>发生某种情况时执行代码（如点击了一个按钮或数据到达时）</li>
<li>只在必要时才运行代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator 静态方法创建比较器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先比较LastName再比较FirstName</span></span><br><span class="line">Arrays.sort(people, Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 制定比较器</span></span><br><span class="line">Arrays.sort(people, Comparator.comparing(Person::getName, (s,t) -&gt; Integer.compare(s.length(), t.length()))); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免int, long, double装箱</span></span><br><span class="line">Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length())); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果KeyExtractor（lambda表达式）会返回null，可以使用nullsFirst或nullsLast来指示返回值。比如，一个人没有中名时，getMiddleName会返回null，就可以这样写</span></span><br><span class="line">Comparator.comparing(Person::getMiddleName, Comparator.nullsFirst(naturalOrder()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// nullsFirst方法需要一个比较器，在这里就是比较两个字符串的比较器。naturalOrder方法可以为任何实现了Comparable的类建立一个比较器（实例)。 在这里，Comparator.&lt;String&gt;naturalOrder()正是我们需要的。不管是naturalOrder还是，reverseOrder，null永远排在最前面，剩下非空值的自然顺序或倒序。</span></span><br></pre></td></tr></table></figure>

<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>内部类(inner class)是定义在另一个类中的类。</p>
<p>使用内部类的原因：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li>
<li>内部类可以对同一个包中的其他类隐藏起来</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷</li>
</ol>
<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">            System.out.println(Circle.<span class="keyword">this</span>.radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</li>
<li>显式访问外部类变量或方法：OuterClass.this.VariableName, OuterClass.this.MethodName</li>
<li>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</li>
<li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>内部类中声明的所有静态与都必须是final。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是final，它可能就不是唯一的。</li>
<li>内部类不能有static方法。</li>
<li>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。private修饰，则只能在外部类的内部访问；public修饰，则任何地方都能访问；protected修饰，则只能在同一个包下或者继承外部类的情况下访问；默认访问权限，则只能在同一个包下访问。</li>
</ol>
<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>在一个方法中定义局部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line"> 	</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interval = interval;</span><br><span class="line">    <span class="keyword">this</span>.beep = beep;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The time is:&quot;</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部类不能用public或private访问限制符进行修饰，它的作用域被限定在声明这个局部类的块中。</p>
<p>局部类的优势：对外部世界可以完全地隐藏起来。即使TalkingClock类中的其他代码也不能访问它。除start方法之外，没有任何方法知道TimePrinter类的存在。</p>
<blockquote>
<p>为了能够让actionPerformed方法工作，由于参数beep会在start结束后回收，TimePrinter类在beep域释放之前将beep域用start方法的局部变量进行备份。</p>
</blockquote>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span> </span>&#123;</span><br><span class="line">  ActionListener listener = <span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;The time is:&quot;</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">  t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new SuperType(construction parameters) &#123;</span><br><span class="line">  inner class methods and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，SuperType可以是接口也，也可以是类（内部类扩展）。由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类没有构造器。<strong>构造器参数将被传递给超类的构造器</strong>。实现接口时便没有构造参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展类的匿名类</span></span><br><span class="line"><span class="keyword">new</span> Employee(<span class="string">&quot;Pony Ma&quot;</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1999</span>)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.printHello();</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<ol>
<li>双括号初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;&#123;&#123;add(<span class="string">&quot;Kane&quot;</span>); add(<span class="string">&quot;Lampard&quot;</span>)&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>外层括号建立了ArrayList的一个匿名子类，内层括号则是一个对象构造块。</p>
<ol start="2">
<li>匿名子类的equals方法要注意，考虑<code>getClass() != other.getClass()</code></li>
<li>生成日志或调试消息时，通常希望包含当前类的类名，如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(<span class="string">&quot;Error in &quot;</span> + getClass());</span><br></pre></td></tr></table></figure>

<p>不过，这对于静态方法不work。因为getClass调用的是<code>this.getClass()</code>，而静态方法没有this。所以应该采用以下表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getClass().getEnclosingClass()</span><br></pre></td></tr></table></figure>

<p><code>new Object()&#123;&#125;</code>会建立Object的一个匿名子类的一个匿名对象，<code>getEnclosingClass</code>则得到其外围类，也就是包含这个静态方法的类。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。</p>
<p>例子：遍历数组一次，同时计算出最小值和zuida值。</p>
<p>一般做法：在当前包见一个Pair类，包含两个内部域，再写个方法遍历然后返回值为Pair。在大型项目中，Pair这样大众化的名字很可能被其他程序猿所定义，有可能会产生名字冲突。所以可以将Pair定义为内部公有类来访问。</p>
<p>静态内部类做法：将Pair作为内部公有类定义在ArrayAlg的内部，然后通过ArrayAlg.Pair访问它<code>ArrayAlg.Pair p = ArrayAlg.minmax(d);</code>。由于Pair对象中不需要引用任何其他的对象，为此，可以将这个内部类声明为static。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h4><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) System.out.println(currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) System.out.println(currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyThread mThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">// 或者直接匿名创建</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h5 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h5><blockquote>
<p>JDK5.0 新增</p>
</blockquote>
<ol>
<li><p>创建实现Callable的实现累</p>
</li>
<li><p>实现call方法，将此线程需要中的操作声明在call()中</p>
</li>
<li><p>创建Callable接口实现类的对象</p>
</li>
<li><p>将此Callable接口实现类的对象作为和传递到FutureTask构造器中，创建FutureTask的对象</p>
</li>
<li><p>将FutureTask的对象(FutureTask实现了Runnable和Callable接口)作为参数传递到Thread的构造器中，并调用start()</p>
</li>
<li><p>通过FutureTask的get()方法来获取call()方法的返回值</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用</span></span><br><span class="line">SumThread sumThread = <span class="keyword">new</span> SumThread();</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(sumThread);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  thread.start();</span><br><span class="line">  System.out.println(futureTask.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ )&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SumThread sumThread = <span class="keyword">new</span> SumThread();</span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(sumThread);</span><br><span class="line">service.submit(futureTask1);</span><br><span class="line">service.execute(sumThread);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(futureTask1.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">service.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;, <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ )&#123;</span><br><span class="line">            res += i;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Callable %s:%d\n&quot;</span>, Thread.currentThread().getName(), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ )&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Runnable %s:%d\n&quot;</span>, Thread.currentThread().getName(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="四种方式的比较"><a href="#四种方式的比较" class="headerlink" title="四种方式的比较"></a>四种方式的比较</h5><ol>
<li>Java只有单继承，如果使用继承的方式就只能继承Thread</li>
<li>继承方式的共享数据必须使用静态属性，而实现类由于可以重复使用单个实例所以天然共享属性值</li>
<li>Thread类其实本身也实现了Runnable接口，两种方式都需要重写run()</li>
<li>Callable接口中的call方法可以抛出异常，可以有返回值，支持泛型</li>
<li>线程池可以减少创建、销毁新线程的时间；降低资源消耗；便于线程管理(corePoolSize(核心池大小)，maximumPoolSize(最大线程数)，keepAliveTime(线程没有任务时最多保持多长时间后会终止))</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(sumThread);</span><br><span class="line">service.submit(futureTask1); <span class="comment">// 适用于Callable</span></span><br><span class="line">service.execute(sumThread); <span class="comment">// 适用于Runnable</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(futureTask1.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="同步的方式"><a href="#同步的方式" class="headerlink" title="同步的方式"></a>同步的方式</h5><ol>
<li><p>同步代码块：</p>
<p>继承Thread类的同步方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.class) &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable类的同步方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程必须要共用同一把锁（同步监视器）</p>
</li>
<li><p>同步方法synchronize修饰方法</p>
<p>同步方法不需要显示声明同步监视器。</p>
<p>非静态的同步方法，同步监视器是this</p>
<p>静态的同步方法，同步监视器是当前类本身（class）</p>
</li>
</ol>
<h4 id="线程安全式单例"><a href="#线程安全式单例" class="headerlink" title="线程安全式单例"></a>线程安全式单例</h4><ol>
<li><p>懒汉式单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>饿汉式单例</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>线程安全式懒汉式单例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Bank.class) &#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Bank();</span><br><span class="line">        	&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul>
<li>New 新建</li>
<li>Runnable 可运行</li>
<li>Blocked 被阻塞</li>
<li>Waiting 等待</li>
<li>Timed waiting 计时等待</li>
<li>Terminated 被终止</li>
</ul>
<img src="/2021/01/27/javacore1/image-20210406184642799.png" class="">

<h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p><strong>MAX_PRIORITY: 10</strong></p>
<p><strong>MIN_PRIORITY: 1</strong></p>
<p><strong>NORM_PRIORITY: 5</strong></p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ol>
<li><code>wait()</code>: 执行此方法后进入阻塞状态并释放同步监视器</li>
<li><code>notify()</code>: 执行此方法后就会唤醒一个wait中的线程，优先换新优先级高的</li>
<li><code>notifyAll()</code>: 一旦执行此方法，就会唤醒所有被wait的线程</li>
</ol>
<p>说明：</p>
<ol>
<li><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>三个方法必须使用在同步代码块或同步方法中。</li>
<li><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则引发<code>IllegalMonitorStateException</code>异常。</li>
<li><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 定义在java.lang.Object中。原因在于任何类都可以充当同步监视器，所以其子类都应该继承该方法。</li>
</ol>
<h5 id="sleep-和-wait-的异同"><a href="#sleep-和-wait-的异同" class="headerlink" title="sleep() 和 wait() 的异同"></a>sleep() 和 wait() 的异同</h5><p>相同点：一旦执行方法，都可使得当前的线程进入阻塞状态。</p>
<p>不同点：</p>
<ol>
<li>两个方法声明的位置不同：Thread类中声明sleep(), Object类中声明wait()</li>
<li>调用的要求不同：sleep() 可以在任何需要的场景下调用。wait()必须使用在同步代码块或者同步方法中</li>
<li>sleep方法不会释放同步监视器，而wait会释放同步监视器，wait()阻塞后需要被notify()唤醒</li>
</ol>
<h4 id="Thread类的方法"><a href="#Thread类的方法" class="headerlink" title="Thread类的方法"></a>Thread类的方法</h4><ul>
<li>getPriority(): 返回线程优先值</li>
<li>setPriority(int newPriority): 改变线程的优先级</li>
</ul>
<p>高优先级的线程会抢占地优先级线程cpu的执行权，但只是从概率上讲，不能保证高优先级的线程一定在低优先级线程之前执行。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h5><p>可重入性是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。如果是不可重入锁，那么在将要第二次获得锁时，自己也会被阻塞。</p>
<h5 id="可打断性"><a href="#可打断性" class="headerlink" title="可打断性"></a>可打断性</h5><p><code>lock.lock</code>：不可打断锁</p>
<p><code>lock.lockInterruptedly</code>: 可以被其他线程打断</p>
<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>尝试活得锁，等待超过一定时间就放弃获得锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;<span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)  <span class="comment">/* 尝试等待1秒，如果获得到锁返回真，否则假 */</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;InterruptedException e&#125; &#123;</span><br><span class="line">  <span class="comment">// tryLock具有可打断性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">finally</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="别用Stack！"><a href="#别用Stack！" class="headerlink" title="别用Stack！"></a>别用Stack！</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg">详情</a><br>stack的推荐写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>不推荐的写法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>原因:<br>Java中的Stack继承了Vector，从而导致了Stack除了自身该有的方法之外还包括了很多父类Vector的公共方法，比如动态数组的add</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.add(<span class="number">1</span>, <span class="number">666</span>);</span><br></pre></td></tr></table></figure>
<p>这破坏了对于栈的封装。从设计原理上来说Stack和Vector之间的关系，不应该是继承关系，而应该是组合关系(composition)，也就是”has-a”的关系。<br><strong>那为什么Java官方推荐使用<code>Deque</code>接口呢?</strong></p>
<p>接口最大的意义在于解耦了Stack和其底层结构。底层开发人员可以随意维护自己的LinkedList类或者ArrayDeque类，只要他们满足Queue接口规定的规范；开发者可以选择合适的数据结构来定义Queue。</p>
<p><strong>Deque的问题</strong><br>Deque是一个双向列表，也就是说可以在两端都可以做插入和删除的操作，这也同样违背了栈只能在一端做插入和删除的概念。如何解决？只能自己再在这个基础之上封装一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T object)</span></span>;</span><br><span class="line">  <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;T&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        deque.addFirst(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么是ArrayDeque?</strong><br>动态数组扩容操作，链表不涉及扩容理论上时间复杂度为$O(1)$。虽然如此，可实际上，当数据量达到一定成都的时候，链表的性能是远远低于动态数组的。这是因为，每添加一个元素，都需要重新创建一个Node类的对象，也就是都需要进行一次new的内存操作。而对内存的操作，是非常慢的。<code>在实践中，尤其面对大规模数据的时候，不应该使用链表</code>。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/04/%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E5%87%89%E7%BB%8F20200804/" rel="prev" title="字节校招凉经20200804">
      <i class="fa fa-chevron-left"></i> 字节校招凉经20200804
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/21/%E8%85%BE%E8%AE%AF%E5%AE%9E%E4%B9%A0%E5%87%89%E7%BB%8F20210317/" rel="next" title="腾讯实习凉经20210317">
      腾讯实习凉经20210317 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">基础语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">注意不要编写返回引用可变对象的访问器方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A7%81%E6%9C%89%E5%9F%9F"><span class="nav-number">2.2.</span> <span class="nav-text">一个类的方法可以访问这个类的任意对象的私有域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E5%AE%9E%E4%BE%8B%E5%9F%9F%EF%BC%8C%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9F%9F%E3%80%82"><span class="nav-number">2.3.</span> <span class="nav-text">final实例域，构建对象时必须初始化这样的域。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E9%9D%99%E6%80%81%E5%9F%9F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">static静态域和静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">this构造方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9F%9F%E5%B0%81%E8%A3%85"><span class="nav-number">2.6.</span> <span class="nav-text">可见性修饰符和数据域封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.7.</span> <span class="nav-text">类设计方法建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-number">2.8.</span> <span class="nav-text">方法参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-number">3.</span> <span class="nav-text">继承与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">3.1.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">3.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.</span> <span class="nav-text">抽象类和接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">3.5.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#equals"><span class="nav-number">3.5.1.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashCode"><span class="nav-number">3.5.2.</span> <span class="nav-text">hashCode</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">为什么要有 hashCode?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">为什么重写 equals 时必须重写 hashCode 方法?</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toString-NaN"><span class="nav-number">3.5.3.</span> <span class="nav-text">toString</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="nav-number">3.6.</span> <span class="nav-text">对象包装器与自动装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">参数数量可变的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">3.8.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84-reflective"><span class="nav-number">3.9.</span> <span class="nav-text">反射(reflective)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Class%E7%B1%BB"><span class="nav-number">3.9.1.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.9.2.</span> <span class="nav-text">检查类的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%9F%9F"><span class="nav-number">3.9.3.</span> <span class="nav-text">运行时反射分析对象域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81"><span class="nav-number">3.9.4.</span> <span class="nav-text">使用反射编写泛型数组代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%88%E7%B1%BB%E4%BC%BC%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">3.9.5.</span> <span class="nav-text">传递类方法（类似函数指针）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7"><span class="nav-number">3.10.</span> <span class="nav-text">继承的设计技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">接口、lambda表达式和内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">默认方法冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#clone"><span class="nav-number">4.1.2.</span> <span class="nav-text">clone</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BE%8B%E5%AD%90"><span class="nav-number">4.2.1.</span> <span class="nav-text">表达式例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.2.2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.4.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.2.5.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.6.</span> <span class="nav-text">处理lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.3.1.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.3.2.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.3.3.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">4.3.4.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">创建线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.1.3.</span> <span class="nav-text">实现Callable接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.4.</span> <span class="nav-text">使用线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">5.1.5.</span> <span class="nav-text">四种方式的比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.6.</span> <span class="nav-text">同步的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%BC%8F%E5%8D%95%E4%BE%8B"><span class="nav-number">5.2.</span> <span class="nav-text">线程安全式单例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.3.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">5.4.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">5.5.</span> <span class="nav-text">线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">5.5.1.</span> <span class="nav-text">sleep() 和 wait() 的异同</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">Thread类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">5.7.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">5.7.1.</span> <span class="nav-text">可重入性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E6%80%A7"><span class="nav-number">5.7.2.</span> <span class="nav-text">可打断性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="nav-number">5.7.3.</span> <span class="nav-text">锁超时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%AB%E7%94%A8Stack%EF%BC%81"><span class="nav-number">6.1.</span> <span class="nav-text">别用Stack！</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhewen Lyu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zhewen Lyu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZavierLyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZavierLyu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xzavierlv@outlook.com" title="E-Mail → mailto:xzavierlv@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhewen Lyu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-60f13baaa3c3f1ad" async="async"></script>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
